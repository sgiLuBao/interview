# mybatis

![image-20221120192930142](C:\Users\zly\AppData\Roaming\Typora\typora-user-images\image-20221120192930142.png)

![image-20221120193451409](C:\Users\zly\AppData\Roaming\Typora\typora-user-images\image-20221120193451409.png)

![img](https://nimg.ws.126.net/?url=http%3A%2F%2Fdingyue.ws.126.net%2F2020%2F1230%2F851105a6p00qm5gg7001uc000hs00clm.png&thumbnail=660x2147483647&quality=80&type=jpg)

# redis

## 分布式锁

原文链接：https://blog.csdn.net/weixin_46129192/article/details/126010250

1)setnx:redis提供的分布式锁
存在问题：线程还没释放锁系统宕机了，造成死锁
2）setnx +setex：给锁设置过期时间，到期自动删除。
存在问题：因为加锁和过期时间设置非原子，存在设置超时时间失败情况，导致死锁
3）set(key,value,nx,px):将setnx+setex变成原子操作
存在问题：加锁和释放锁不是同一个线程的问题。假如线程1业务还没执行完，锁过期释放，线程2获取锁执行，线程1执行完业务删除锁删除的就是线程2的，然后其他线程又可获取锁执行，线程2执行完释放锁删除的是别人的，如此往复，导致并发安全问题。
4.方法1：在value中存入uuid(线程唯一标识)，删除锁时判断该标识，同时删除锁需保证原子性，否则还是有删除别人锁问题，可通过lua或者redis事务释放锁
方法2：利用redis提供的第三方类库，Redisson也可解决任务超时，锁自动释放问题。其通过开启另一个服务，后台进程定时检查持有锁的线程是否继续持有锁了，是将锁的生命周期重置到指定时间，即防止线程释放锁之前过期，所以将锁声明周期通过重置延长。
Redission也可解决不可重入问题（AQS,计数）

问题：但上述方案能保证单机系统下的并发访问安全，实际为了保证redis高可用，redis一般会集群部署。单机解决方案会出现锁丢失问题。如线程set值后成功获取锁但主节点还没来得及同步就宕机了，从节点选举成为主节点，没有锁信息，此时其他线程就可以加锁成功，导致并发问题。

5）redis集群解决方案,使用redlock解决:

顺序向5个节点请求加锁（5个节点相互独立，没任何关系）
根据超时时间来判断是否要跳过该节点
如果大于等于3节点加锁成功，并且使用时间小于锁有效期，则加锁成功，否则获取锁失败，解锁